---
title: Green Dot documentation - Landing page
description: Security and DX focused NodeJs backend framework
template: splash
hero:
  tagline: Fast, Secure & DX Friendly
---

import GitHubButton from 'react-github-btn'
import { Card, CardGrid, Code, LinkButton, Icon } from '@astrojs/starlight/components';
import { ToyBrick, Database, KeySquare, ScanFace, User, SquareCode, BookCheck, Package, Ellipsis, CodeXml, Zap } from 'lucide-astro'

{/* 
//  â•”â•â•â•— â•”â•â•â•— â•”â•â•â•— â•â•â•¦â•â• â•¦  â•¦ â•”â•â•â•— â•”â•â•â•— â•”â•â•â•
//  â• â•   â• â•   â• â•â•â•£   â•‘   â•‘  â•‘ â• â•â•¦â• â• â•   â•šâ•â•â•—
//  â•©    â•šâ•â•â• â•©  â•©   â•©   â•šâ•â•â• â•© â•š  â•šâ•â•â• â•â•â•â•
 */}

## Features Overview

ğŸ§­ Back/Front [Type-safe API route declarations](/guides/api-services/), shared models   
ğŸ”’ Unified [model definitions and security configuration](/guides/models-and-daos/)  
ğŸ”Œ Powerful [plugin system](/plugins/1_plugins/) (Managed Login, ApiKey Login...) (BETA)  
ğŸª„ File generation to generate project, databases, apps, models...so you get up and running in no time
ğŸ—ƒï¸ MongoDB integration with all the way type safety (others database drivers coming soon)  
ğŸ‘¨â€ğŸ’» DX and intellisense friendly  
ğŸ—ï¸ Generate it's own SDK to use in frontend, get your backend data without await, useEffects or state management: (Eg: `const result = $.useQuery.myApiRoute()`)  
âš¡  Fully cached in frontend via TanStack Query  
ğŸ“¦ [VSCode / Cursor Plugin](https://marketplace.visualstudio.com/items?itemName=topkat.green-dot-vscode-module)


{/* 
//  â•”â•â•â• â•”â•â•â•— â•”â•â•â•— â•¦  â•¦ â•â•¦â• â•”â•â•â•— â•”â•â•â•— â•”â•â•â•
//  â•šâ•â•â•— â• â•   â• â•â•¦â• â•šâ•— â•‘  â•‘  â•‘    â• â•   â•šâ•â•â•—
//  â•â•â•â• â•šâ•â•â• â•© â•š   â•šâ•â• â•â•©â• â•šâ•â•â• â•šâ•â•â• â•â•â•â•
 */}
<h2 class='flex flex-row items-center mb-4'>
<Icon name='seti:tsconfig' class='inline mr-3 text-accent-400' style={{display: 'inline'}} />
API route declaration
</h2>

    Generate a new api route with `npx green_dot generate` and configure it:<br /><br />

```ts twoslash title=getUserByEmailCustom.api.ts
function svc(config: {
  for: [string | {role: string, hasValidatedEmail: boolean}],
  main(ctx: { _id: string, role: 'appUser' }, body: {email: string}),
  /** Custom rate limiter for this route */
  rateLimiter: string
  /** Type output for security and backend / frontend type safety */
  output
}) {}
// ---cut---
// @noErrors
export const getUserByEmailCustom = svc({
    for: [
       'customRole', 
       { role: 'user', hasValidatedEmail: true }
    ],
    input: {
        email: _.email().required(),
    },
    output: _.model('myDbName', 'user'),
    rateLimiter: '10/min',
    ...
    async main(ctx, { email }) {
    //                  ^?
        // No need to worry about security here, this db call will automatically apply
        // mask and filter depending on user perm (see below)
        return await ctx.db.user.getOne({ email }) 
    },
})
```
<br/>
**Note**: the above will auto generate a route on `POST myDomain.com/get-user-by-email-custom` based on the `const` value. You can modify this by adding a `route` and `method` config
<br/>
### Frontend usage 
<br/>
In frontend, **everything is well typed**: you just have to import the generated SDK and use it like:<br/>
```ts twoslash
type User = {_id: string, name: string}
const $ = { getUserByEmailCustom(): Promise<User>, useQuery: {getUserByEmailCustom(): User} }
// ---cut---
import { $ } from '@my-company/user-app-sdk'

// @noErrors
const user = await $.getUserByEmailCustom()
// OR if in the context of a react component (cache friendly with tanstack query)
function MyReactComponent() {
    const user = $.useQuery.getUserByEmailCustom()
    //     ^?
    return <div>Welcome {user.name}</div>
    //                           ^?
}
```

    <LinkButton href="./guides/quickstart" variant="minimal" icon="external">
       API services Doc
    </LinkButton>
    <LinkButton href="./guides/quickstart" variant="minimal" icon="external">
      Frontend Usage Doc
    </LinkButton>

<br />
<br />
{/* 
//  â•¦â•—â•”â•¦ â•”â•â•â•— â•”â•â•—  â•”â•â•â•— â•¦    â•”â•â•â•
//  â•‘â•šâ•â•‘ â•‘  â•‘ â•‘  â•‘ â• â•   â•‘    â•šâ•â•â•—
//  â•©  â•© â•šâ•â•â• â•šâ•â•â• â•šâ•â•â• â•šâ•â•â• â•â•â•â•
 */}
<h2 class='flex flex-row mb-4'>
<Database size={40} className='-mt-1 mr-2 text-accent-400' />
Shared Models, Unified Security
</h2>

    Generate a new model and DAO (data access object) with `npx green_dot generate` and configure it:<br /><br />

```ts title='company.model.ts'
export const companyModel = _.mongoModel(
  // Automatic timestamp fields
  ['creationDate', 'updateDate'], 
  {
      name: _.string().required(),
      admin: _.ref('user').required(), // ref to user model
      companyIdenfier: _.string().required().unique(), // unique fields
  }
)

export type CompanyModel = InferType<typeof companyModel>
// type may differ when writing (create / update) vs reading
export type CompanyModelWrite = InferTypeWrite<typeof companyModel>
```
<br/>
Dao files are a way to configure the security of your model and expose automatically some method via API (getById, update...). Everything is unified in a single file so security is made easy and comprehensive:
<br/>
```ts title='company.dao.ts'
export const dao = {
  type: 'mongo', // other DBs drivers incoming
  // EXPOSE: auto generate routes and SDK methods with configured access
  expose: [{
    for: 'appUser',
    expose: ['getOne', 'create'], // so an appUser cannot update or delete
  }, {
    for: 'admin',
    expose: ['read', 'write'], // admin has full access
  }],
  // FILTER 
  filter: [{
    for: 'appUser',
    filter: (ctx, filter) => {
      // here, we force admin fields to be equal to user._id
      // in other terms, user must be admin of the company to read/write model
      filter.admin === ctx._id
    }
  }],
  // MASK
  mask: [{
    for: 'appUser',
    mask: ctx => ({
      // user cannot see businessData field
      businessData: true,
    }),
  }, {
    on: 'read',
    mask: ctx => ({
      // no one can read password
      password: true,
      // dynamically hide fields according to user perms
      businessData: ctx.isBusinessHolder,
    }),
  }],
  // automatically populate (left join) data for this model,
  // security is applied to any level of populated field
  populate: [{ path: 'admin', select: ['firstName']}],
} satisfies MongoDao<User>

export default dao
```

<br />
<br />

{/* 
//  â•¦â•—â•”â•¦ â•”â•â•â•— â•”â•â•â•— â•”â•â•â•—
//  â•‘â•šâ•â•‘ â•‘  â•‘ â• â•â•¦â• â• â•  
//  â•©  â•© â•šâ•â•â• â•© â•š  â•šâ•â•â•
 */}
<h2 class='flex flex-row mb-4'>
And much more...
</h2>


<CardGrid stagger>
	<Card>
    <h4 class='flex flex-row mb-4'>
      <ToyBrick size={40} className='-mt-1 mr-2 text-accent-400' />
      A powerful plugin system
    </h4>
    Actually 3 plugins can be installed when you run `npx green_dot@latest generate` for the first time:<br/><br/>

    <User /> `GDmanagedLogin`: Managed JWT login, email and password updates with custom emails ([see doc](./plugins/managed-authentication))<br /><br />
    <KeySquare /> `GDapiKeyAuthentication`: Managed 2FA, Pin Code or biometric authentication ([see doc](./plugins/double-authentication))<br /><br />
    <ScanFace /> `GDdoubleAuthentication`: Api Key Authentication ([see doc](./plugins/double-authentication))<br />

	</Card>
	<Card>
		<h4 class='flex flex-row mb-4'>
      <SquareCode size={40} className='-mt-1 mr-2 text-accent-400' />
      Loved by your IDE
    </h4>
    <div class="text-lg text-gray-600 dark:text-gray-300 font-light">
      <BookCheck /> Whenever you are lost, just hover the name of anything green_dot to see a full documentation without leaving your IDE<br /><br />
      <Package /> Cursor and VSCode plugins for specific syntax highlights and helpers<br /><br />
      <CodeXml /> Use `gd_` snippets anywhere to help with writing code faster<br />
    </div>
	</Card>
	<Card>
    <h4 class='flex flex-row mb-4'>
      <Zap size={40} className='-mt-1 mr-2 text-accent-400' />
      Performance friendly
    </h4>
      * All your requests are automatically cached with `@tanstack/react-query` to use in frontend components without the need to `await` your requests
      * refresh cache or disable it on demand via simple configuration (in API service or SDK directly)
      * prefetch heavy requests via `$.prefetch.myHeavyRequest()` so that when you need them they'll load instantly
      * defer requests to make them async `$.defer.myHeavyRequest()`
    <LinkButton href="./reference/tanstack-query-and-caching" variant="minimal" icon="external">
       Learn more about caching and performances
    </LinkButton>
	</Card>
	<Card>
		 <h4 class='flex flex-row mb-4'>
      <Ellipsis size={40} className='-mt-1 mr-2 text-accent-400' />
      Plus
    </h4>
      * File Generation from template via `npx green_dot generate`
      * MongoDb integration (more database to come)
      * Auto generates a swagger documentation
      * Open Source
    <div class='flex flex-row justify-center'>
    <LinkButton href="./guides/quickstart" icon="right-arrow">
      Quick Start
    </LinkButton>
    <LinkButton href="./guides/quickstart" variant="minimal" icon="external">
      Read the docs
    </LinkButton>
    </div>
	</Card>
</CardGrid>


